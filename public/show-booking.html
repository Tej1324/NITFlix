<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Book Seats - BookMyNIT</title>
  <link rel="stylesheet" href="css/show-booking.css">
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
<!-- Or use PNG -->
<link rel="icon" type="image/png" href="favicon.png" />

  <style>
    .seat.booked, .seat.locked {
      background-color: #aaa !important;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <header><h1><span>Book</span>MyNIT - Seat Booking</h1></header>
  <main>
    <p id="userInfo"></p>
<div id="seatWrapperContainer">
  <div id="seatWrapper"></div>
</div>
    <div>SCREEN THIS WAY</div>

    <div class="legend">
      <div class="legend-item"><div class="seat"></div> Available</div>
      <div class="legend-item"><div class="seat selected"></div> Selected</div>
      <div class="legend-item"><div class="seat booked"></div> Booked</div>
    </div>
    <div id="controls">
      <button id="confirmBtn">Confirm Booking</button>
    </div>
  </main>
  <footer><p>&copy; 2025 BookMyNIT. All rights reserved.</p></footer>

  <script type="module">
    import { db, auth, doc, getDoc, setDoc, updateDoc, collection, getDocs, onAuthStateChanged, serverTimestamp, runTransaction } from "./js/firebase.js";

    const seatWrapper = document.getElementById("seatWrapper");
const seatWrapperContainer = document.getElementById("seatWrapperContainer");
    const confirmBtn = document.getElementById("confirmBtn");
    let selectedSeats = [];
    let currentUser = null;
    let seatTimers = {}; // Track timeout timers for each seat

     const seatLayout = [
      {
        title: 'â‚¹450 ROYALE CLUB',
        priceKey: 'ROYALE CLUB',
        rows: {
          A: [1,2,3,4,5,6,7,8,9,10,11]        }
      },
      {
        title: 'â‚¹360 ROYALE',
        priceKey: 'ROYALE',
        rows: {
          B: [1,2,3,4,5,6,7,8,9,12,13,14],
          C: [1,2,3,4,5,6,7,8,9,12,13,14],
          D: [1,2,3,4,5,6,7,8,9,12,13,14]
        }
      },
      {
        title: 'â‚¹330 CLUB',
        priceKey: 'CLUB',
        rows: {
          E: [1,2,3,4,5,6,7,8,9,14],
          F: [1,2,3,4,5,6,7,8,9,14],
          G: [1,2,3,4,5,6,7,8,9,14],
          H: [1,2,3,4,5,6,7,8,9,12,13,14],
          I: [1,2,3,4,5,6,7,8,9,12,13,14]
        }
      },
      {
        title: 'â‚¹300 EXECUTIVE',
        priceKey: 'EXECUTIVE',
        rows: {
          J: [1,2,3,4,5,6,7,8,9,12,13,14],
          K: [1,2,3,4,5,6,7,8,9,12,13,14]
        }
      }
    ];


    let seatStatusMap = {}; // seatId -> booked/locked

   import { onSnapshot } from "./js/firebase.js";

onAuthStateChanged(auth, (user) => {
  if (!user) return window.location.href = "login.html";
  currentUser = user;
  // Realtime listener to all seats
  onSnapshot(collection(db, "shows", "currentShow", "seats"), (snapshot) => {
  console.log("Snapshot triggered!");
  seatStatusMap = {}; // Reset before rebuild

  snapshot.forEach(seatDoc => {
    const data = seatDoc.data();
    const seatId = seatDoc.id;

    if (data.status === "locked") {
      seatStatusMap[seatId] = "locked";
      seatStatusMap[seatId + "_by"] = data.lockedBy;
    } else if (data.status === "booked") {
      seatStatusMap[seatId] = "booked";
    } else {
      seatStatusMap[seatId] = "available";
    }
  });

  console.log("Rendering with seatStatusMap:", seatStatusMap);
  renderLayout();
});


console.log("Rendering with seatStatusMap:", seatStatusMap);
renderLayout();




          function renderLayout() {
  seatWrapper.innerHTML = ""; // ðŸ’¡ Don't forget to clear the layout before re-rendering

  seatLayout.forEach(section => {
    const sectionDiv = document.createElement('div');
    sectionDiv.className = 'section';

    const title = document.createElement('h3');
    title.textContent = section.title;
    sectionDiv.appendChild(title);

    for (const row in section.rows) {
      const rowDiv = document.createElement('div');
      rowDiv.className = 'row';
      const seatNumbers = section.rows[row];
      const maxSeatNum = Math.max(...seatNumbers);

      for (let i = 1; i <= maxSeatNum; i++) {
        if (seatNumbers.includes(i)) {
          const seatId = `${row}${i}`;
          const btn = document.createElement('button');
          btn.className = 'seat';
          btn.textContent = i.toString().padStart(2, '0');
          btn.dataset.seat = seatId;
          btn.dataset.priceKey = section.priceKey;

          const status = seatStatusMap[seatId];
          const lockedByCurrentUser = seatStatusMap[seatId + '_by'] === currentUser?.uid;

          if (status === 'locked' && !lockedByCurrentUser) {
            btn.classList.add('locked');
            btn.disabled = true;
            btn.title = "This seat is temporarily locked by another user.";
          } else if (status === 'locked' && lockedByCurrentUser) {
            // Keep it interactive so user can deselect/unlock
            btn.classList.add('selected');
            btn.disabled = false;
            btn.title = "You have locked this seat. Click to deselect.";
            btn.addEventListener('click', () => toggleSeat(btn));
          } else if (status === 'booked') {
            btn.classList.add('booked');
            btn.disabled = true;
            btn.title = "This seat is booked.";
          } else {
            btn.classList.remove('locked', 'booked');
            btn.disabled = false;
            btn.title = "Click to select";
            btn.addEventListener('click', () => toggleSeat(btn));
          }

          rowDiv.appendChild(btn);
        } else {
          const gap = document.createElement('div');
          gap.className = 'seat gap';
          rowDiv.appendChild(gap);
        }
      }
      sectionDiv.appendChild(rowDiv);
    }
    seatWrapper.appendChild(sectionDiv);
  });
}


    async function toggleSeat(btn) {
  const seatId = btn.dataset.seat;
  const priceKey = btn.dataset.priceKey;

  if (btn.classList.contains("selected")) {
    // Deselect locally and unlock in database
    btn.classList.remove("selected");
    selectedSeats = selectedSeats.filter(s => s.id !== seatId);
    
    // Clear the timeout timer for this seat
    if (seatTimers[seatId]) {
      clearTimeout(seatTimers[seatId]);
      delete seatTimers[seatId];
    }
    
    // Unlock the seat in database with safety check
    try {
      const seatRef = doc(db, "shows", "currentShow", "seats", seatId);
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(seatRef);
        if (!snap.exists()) return;
        const data = snap.data();
        if (data.status === 'locked' && data.lockedBy === currentUser.uid) {
          tx.update(seatRef, {
            status: "available",
            lockedBy: null,
            lockedAt: null
          });
        }
      });
    } catch (err) {
      console.error("Failed to unlock seat:", err);
    }
  } else {
    const seatRef = doc(db, "shows", "currentShow", "seats", seatId);
    // Select locally and attempt to lock in database atomically
    btn.classList.add("selected");
    selectedSeats.push({ id: seatId, priceKey });
    
    // Lock the seat immediately in database using transaction
    try {
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(seatRef);
        if (snap.exists()) {
          const data = snap.data();
          if (data.status === 'available' || data.status === undefined) {
            tx.update(seatRef, {
              status: "locked",
              lockedBy: currentUser.uid,
              lockedAt: serverTimestamp()
            });
          } else {
            throw new Error("Seat no longer available");
          }
        } else {
          // In case documents are not pre-created
          tx.set(seatRef, {
            status: "locked",
            lockedBy: currentUser.uid,
            lockedAt: serverTimestamp()
          });
        }
      });
      
      // Set a 10-minute timeout to auto-unlock the seat if not booked
      seatTimers[seatId] = setTimeout(async () => {
        try {
          // Safely unlock via transaction if still locked by this user
          await runTransaction(db, async (tx) => {
            const s = await tx.get(seatRef);
            if (s.exists()) {
              const d = s.data();
              if (d.status === 'locked' && d.lockedBy === currentUser.uid) {
                tx.update(seatRef, {
                  status: "available",
                  lockedBy: null,
                  lockedAt: null
                });
              }
            }
          });
          // Remove from selected seats if still selected
          selectedSeats = selectedSeats.filter(s => s.id !== seatId);
          alert(`Seat ${seatId} has been automatically unlocked due to timeout. Please reselect if needed.`);
        } catch (err) {
          console.error("Failed to auto-unlock seat:", err);
        }
        delete seatTimers[seatId];
      }, 10 * 60 * 1000); // 10 minutes
      
    } catch (err) {
      console.error("Failed to lock seat:", err);
      // If locking fails, remove from selection
      btn.classList.remove("selected");
      selectedSeats = selectedSeats.filter(s => s.id !== seatId);
      alert("Failed to lock seat. Please try again.");
    }
  }

  // Optional: update price/seat count UI
  updateSummary?.(); // only call if function exists
}


  confirmBtn.addEventListener("click", async () => {
  if (selectedSeats.length === 0) {
    alert("Select at least one seat.");
    return;
  }

  // Seats are already locked when selected, so just proceed to payment
  sessionStorage.setItem("selectedSeats", JSON.stringify(selectedSeats));
  
  // Clear all timers since user is proceeding to payment
  Object.values(seatTimers).forEach(timer => clearTimeout(timer));
  seatTimers = {};
  
  window.location.href = "payment.html";
});

// Clean up locked seats when user leaves the page without booking
window.addEventListener('beforeunload', async () => {
  // Clear all timers
  Object.values(seatTimers).forEach(timer => clearTimeout(timer));
  
  // Unlock all selected seats (safely)
  for (const seat of selectedSeats) {
    try {
      const seatRef = doc(db, "shows", "currentShow", "seats", seat.id);
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(seatRef);
        if (!snap.exists()) return;
        const data = snap.data();
        if (data.status === 'locked' && data.lockedBy === currentUser?.uid) {
          tx.update(seatRef, {
            status: "available",
            lockedBy: null,
            lockedAt: null
          });
        }
      });
    } catch (err) {
      console.error("Failed to unlock seat on page unload:", err);
    }
  }
});

});
let isDown = false;
let startX;
let scrollLeft;

seatWrapperContainer.addEventListener('mousedown', (e) => {
  isDown = true;
  seatWrapperContainer.classList.add('active');
  startX = e.pageX - seatWrapperContainer.offsetLeft;
  scrollLeft = seatWrapperContainer.scrollLeft;
});
seatWrapperContainer.addEventListener('mouseleave', () => {
  isDown = false;
  seatWrapperContainer.classList.remove('active');
});
seatWrapperContainer.addEventListener('mouseup', () => {
  isDown = false;
  seatWrapperContainer.classList.remove('active');
});
seatWrapperContainer.addEventListener('mousemove', (e) => {
  if (!isDown) return;
  e.preventDefault();
  const x = e.pageX - seatWrapperContainer.offsetLeft;
  const walk = (x - startX) * 1.5; // scroll speed
  seatWrapperContainer.scrollLeft = scrollLeft - walk;
});


  </script>
</body>
</html>
